<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>browser = !(os_browser == browser_not_a_browser);

// auto complete the quadtree
init = false;
auto = true;
help = true;
if (auto)
    alarm[0] = 20;

// quadtree settings
node_list = -1;
threshold = 0.1;
col_range = floor(threshold*255);
maxdepth = 7;

// debug stuff
total = 0;
scale = 1;

spr[0] = spr_test1;
spr[1] = spr_test2;
spr[2] = spr_test3;
image = spr[0];
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (init)
    {
    alarm[0] = 20;
    
    if !(ds_exists(node_list,ds_type_list))
        exit;
    
    var size = ds_list_size(node_list);
    for(var i=0; i&lt;size; i++;)
        {
        // find the quadtree nodes details
        var temp_node = ds_list_find_value(node_list,0);
        var nx = ds_list_find_value(temp_node,0);
        var ny = ds_list_find_value(temp_node,1);
        var nw = ds_list_find_value(temp_node,2);
        var nh = ds_list_find_value(temp_node,3);
        var nwh = nw/2;
        var nhh = nh/2;
        
        ds_list_destroy(temp_node);
        ds_list_delete(node_list,0);
        
        pix[0] = surface_getpixel(surf_quad,nx,ny); // 0
        pix[1] = surface_getpixel(surf_quad,nx+nwh,ny); // 1
        pix[2] = surface_getpixel(surf_quad,nx + nw-1,ny); // 2
        pix[3] = surface_getpixel(surf_quad,nx,ny+nhh); // 3
        pix[4] = surface_getpixel(surf_quad,nx+nwh,ny+nhh); // 4
        pix[5] = surface_getpixel(surf_quad,nx + nw-1,ny+nhh); // 5
        pix[6] = surface_getpixel(surf_quad,nx,ny + nh-1); // 6
        pix[7] = surface_getpixel(surf_quad,nx+nwh,ny + nh-1); // 7
        pix[8] = surface_getpixel(surf_quad,nx + nw-1,ny + nh-1); // 8
        
        col[0] = merge_color(merge_color(pix[0],pix[1],0.1),merge_color(pix[3],pix[4],0.9),0.2); // top left
        col[1] = merge_color(merge_color(pix[1],pix[2],0.1),merge_color(pix[4],pix[5],0.9),0.4); // top right
        col[2] = merge_color(merge_color(pix[3],pix[4],0.1),merge_color(pix[6],pix[7],0.9),0.6); // bottom left
        col[3] = merge_color(merge_color(pix[4],pix[5],0.1),merge_color(pix[7],pix[8],0.9),0.8); // bottom right
        
        /*
        // poll the quadtree
        col[0] = surface_getpixel(surf_quad,nx,ny); // top left
        col[1] = surface_getpixel(surf_quad,nx+nwh-1,ny); // top right
        col[2] = surface_getpixel(surf_quad,nx,ny+nhh-1); // bottom left
        col[3] = surface_getpixel(surf_quad,nx + nwh-1,ny + nhh-1); // bottom right
        
        */
        
        // pick color parts from the pixel
        for(var j=0; j&lt;4; j++;)
            {
            r[j] = color_get_red(col[j]);
            g[j] = color_get_green(col[j]);
            b[j] = color_get_blue(col[j]);
            v[j] = color_get_value(col[j]);
            }
        
        // find disimilarities
        var split = false;
        if (abs(r[0]-r[1]) &gt; col_range) or (abs(r[0]-r[2]) &gt; col_range) or (abs(r[0]-r[3]) &gt; col_range) or (abs(r[1]-r[2]) &gt; col_range) or (abs(r[1]-r[3]) &gt; col_range) or (abs(r[2]-r[3]) &gt; col_range)
            split = true;
        else if (abs(g[0]-g[1]) &gt; col_range) or (abs(g[0]-g[2]) &gt; col_range) or (abs(g[0]-g[3]) &gt; col_range) or (abs(g[1]-g[2]) &gt; col_range) or (abs(g[1]-g[3]) &gt; col_range) or (abs(g[2]-g[3]) &gt; col_range)
            split = true;
        else if (abs(b[0]-b[1]) &gt; col_range) or (abs(b[0]-b[2]) &gt; col_range) or (abs(b[0]-b[3]) &gt; col_range) or (abs(b[1]-b[2]) &gt; col_range) or (abs(b[1]-b[3]) &gt; col_range) or (abs(b[2]-b[3]) &gt; col_range)
            split = true;
        else if (abs(v[0]-v[1]) &gt; col_range) or (abs(v[0]-v[2]) &gt; col_range) or (abs(v[0]-v[3]) &gt; col_range) or (abs(v[1]-v[2]) &gt; col_range) or (abs(v[1]-v[3]) &gt; col_range) or (abs(v[2]-v[3]) &gt; col_range)
            split = true;
        
        // split the quadtree
        if (split) and (nw &gt; min_w) and (nh &gt; min_h)
            {
            total += 4;
            
            // draw rectangle color
            surface_set_target(surf_data);
            draw_set_color(col[0]);
            draw_rectangle(nx,ny,nx+nwh,ny+nhh,0);
            draw_set_color(col[1]);
            draw_rectangle(nx+nwh,ny,nx+nw,ny+nhh,0);
            draw_set_color(col[2]);
            draw_rectangle(nx,ny+nhh,nx+nwh,ny+nh,0);
            draw_set_color(col[3]);
            draw_rectangle(nx+nwh,ny+nhh,nx+nw,ny+nh,0);
            surface_reset_target();
            
            // draw subdivisions
            surface_set_target(surf_subd);
            draw_set_color(c_white);
            draw_rectangle(nx,ny,nx+nwh,ny+nhh,1);
            draw_rectangle(nx+nwh,ny,nx+nw,ny+nhh,1);
            draw_rectangle(nx,ny+nhh,nx+nwh,ny+nh,1);
            draw_rectangle(nx+nwh,ny+nhh,nx+nw,ny+nh,1);
            surface_reset_target();
            
            var temp_node = ds_list_create();
            ds_list_add(temp_node,nx,ny,nwh,nhh);
            ds_list_add(node_list,temp_node);
            
            var temp_node = ds_list_create();
            ds_list_add(temp_node,nx+nwh,ny,nwh,nhh);
            ds_list_add(node_list,temp_node);
            
            var temp_node = ds_list_create();
            ds_list_add(temp_node,nx,ny+nhh,nwh,nhh);
            ds_list_add(node_list,temp_node);
            
            var temp_node = ds_list_create();
            ds_list_add(temp_node,nx+nwh,ny+nhh,nwh,nhh);
            ds_list_add(node_list,temp_node);
            }
        }
    }
else
    {
    init = true;
    alarm[0] = 20;
    
    img_w = sprite_get_width(image);
    img_h = sprite_get_height(image);
    
    min_w = img_w/power(2,maxdepth);
    min_h = img_h/power(2,maxdepth);
    
    // draw the image to a surface
    surf_quad = surface_create(img_w,img_h);
    surface_set_target(surf_quad);
    draw_clear(c_black);
    draw_sprite(image,0,0,0);
    surface_reset_target();
    
    // make a surface to show quadtree data
    surf_data = surface_create(img_w,img_h);
    surface_set_target(surf_data);
    draw_clear(c_black);
    surface_reset_target();
    
    // make a surface to show subdivisions
    surf_subd = surface_create(img_w+1,img_h+1);
    surface_set_target(surf_subd);
    draw_clear_alpha(c_black,0);
    surface_reset_target();
    
    // list of nodes
    node_list = ds_list_create();
    
    // create new node
    var temp_node = ds_list_create();
    ds_list_add(node_list,temp_node);
    
    // set new nodes properties (xpos,ypos,w,h);
    ds_list_add(temp_node,0,0,img_w,img_h);
    }
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if !(auto) and (keyboard_check_pressed(vk_space))
    {
    if (init)
        {
        if (ds_exists(node_list,ds_type_list))
            {
            var size = ds_list_size(node_list);
            for(var i=0; i&lt;size; i++;)
                {
                // find the quadtree nodes details
                var temp_node = ds_list_find_value(node_list,0);
                var nx = ds_list_find_value(temp_node,0);
                var ny = ds_list_find_value(temp_node,1);
                var nw = ds_list_find_value(temp_node,2);
                var nh = ds_list_find_value(temp_node,3);
                var nwh = nw/2;
                var nhh = nh/2;
                
                ds_list_destroy(temp_node);
                ds_list_delete(node_list,0);
                
                // poll the quadtree
                pix[0] = surface_getpixel(surf_quad,nx,ny); // 0
                pix[1] = surface_getpixel(surf_quad,nx+nwh,ny); // 1
                pix[2] = surface_getpixel(surf_quad,nx + nw-1,ny); // 2
                pix[3] = surface_getpixel(surf_quad,nx,ny+nhh); // 3
                pix[4] = surface_getpixel(surf_quad,nx+nwh,ny+nhh); // 4
                pix[5] = surface_getpixel(surf_quad,nx + nw-1,ny+nhh); // 5
                pix[6] = surface_getpixel(surf_quad,nx,ny + nh-1); // 6
                pix[7] = surface_getpixel(surf_quad,nx+nwh,ny + nh-1); // 7
                pix[8] = surface_getpixel(surf_quad,nx + nw-1,ny + nh-1); // 8
                
                col[0] = merge_color(merge_color(pix[0],pix[1],0.25),merge_color(pix[3],pix[4],0.75),0.5); // top left
                col[1] = merge_color(merge_color(pix[1],pix[2],0.25),merge_color(pix[4],pix[5],0.75),0.5); // top right
                col[2] = merge_color(merge_color(pix[3],pix[4],0.25),merge_color(pix[6],pix[7],0.75),0.5); // bottom left
                col[3] = merge_color(merge_color(pix[4],pix[5],0.25),merge_color(pix[7],pix[8],0.75),0.5); // bottom right
                
                // pick color parts from the pixel
                for(var j=0; j&lt;4; j++;)
                    {
                    r[j] = color_get_red(col[j]);
                    g[j] = color_get_green(col[j]);
                    b[j] = color_get_blue(col[j]);
                    v[j] = color_get_value(col[j]);
                    }
                
                // find disimilarities
                var split = false;
                if (abs(r[0]-r[1]) &gt; col_range) or (abs(r[0]-r[2]) &gt; col_range) or (abs(r[0]-r[3]) &gt; col_range) or (abs(r[1]-r[2]) &gt; col_range) or (abs(r[1]-r[3]) &gt; col_range) or (abs(r[2]-r[3]) &gt; col_range)
                    split = true;
                else if (abs(g[0]-g[1]) &gt; col_range) or (abs(g[0]-g[2]) &gt; col_range) or (abs(g[0]-g[3]) &gt; col_range) or (abs(g[1]-g[2]) &gt; col_range) or (abs(g[1]-g[3]) &gt; col_range) or (abs(g[2]-g[3]) &gt; col_range)
                    split = true;
                else if (abs(b[0]-b[1]) &gt; col_range) or (abs(b[0]-b[2]) &gt; col_range) or (abs(b[0]-b[3]) &gt; col_range) or (abs(b[1]-b[2]) &gt; col_range) or (abs(b[1]-b[3]) &gt; col_range) or (abs(b[2]-b[3]) &gt; col_range)
                    split = true;
                else if (abs(v[0]-v[1]) &gt; col_range) or (abs(v[0]-v[2]) &gt; col_range) or (abs(v[0]-v[3]) &gt; col_range) or (abs(v[1]-v[2]) &gt; col_range) or (abs(v[1]-v[3]) &gt; col_range) or (abs(v[2]-v[3]) &gt; col_range)
                    split = true;
                
                // split the quadtree
                if (split) and (nw &gt; min_w) and (nh &gt; min_h)
                    {
                    total += 4;
                    
                    // draw rectangle color
                    surface_set_target(surf_data);
                    draw_set_color(col[0]);
                    draw_rectangle(nx,ny,nx+nwh,ny+nhh,0);
                    draw_set_color(col[1]);
                    draw_rectangle(nx+nwh,ny,nx+nw,ny+nhh,0);
                    draw_set_color(col[2]);
                    draw_rectangle(nx,ny+nhh,nx+nwh,ny+nh,0);
                    draw_set_color(col[3]);
                    draw_rectangle(nx+nwh,ny+nhh,nx+nw,ny+nh,0);
                    surface_reset_target();
                    
                    // draw subdivisions
                    surface_set_target(surf_subd);
                    draw_set_color(c_white);
                    draw_rectangle(nx,ny,nx+nwh,ny+nhh,1);
                    draw_rectangle(nx+nwh,ny,nx+nw,ny+nhh,1);
                    draw_rectangle(nx,ny+nhh,nx+nwh,ny+nh,1);
                    draw_rectangle(nx+nwh,ny+nhh,nx+nw,ny+nh,1);
                    surface_reset_target();
                    
                    var temp_node = ds_list_create();
                    ds_list_add(temp_node,nx,ny,nwh,nhh);
                    ds_list_add(node_list,temp_node);
                    
                    var temp_node = ds_list_create();
                    ds_list_add(temp_node,nx+nwh,ny,nwh,nhh);
                    ds_list_add(node_list,temp_node);
                    
                    var temp_node = ds_list_create();
                    ds_list_add(temp_node,nx,ny+nhh,nwh,nhh);
                    ds_list_add(node_list,temp_node);
                    
                    var temp_node = ds_list_create();
                    ds_list_add(temp_node,nx+nwh,ny+nhh,nwh,nhh);
                    ds_list_add(node_list,temp_node);
                    }
                }
            }
        }
    else
        {
        init = true;
        img_w = sprite_get_width(image);
        img_h = sprite_get_height(image);
        
        min_w = img_w/power(2,maxdepth);
        min_h = img_h/power(2,maxdepth);
        
        // draw the image to a surface
        surf_quad = surface_create(img_w,img_h);
        surface_set_target(surf_quad);
        draw_clear(c_black);
        draw_sprite(image,0,0,0);
        surface_reset_target();
        
        // make a surface to show quadtree data
        surf_data = surface_create(img_w,img_h);
        surface_set_target(surf_data);
        draw_clear(c_black);
        surface_reset_target();
        
        // make a surface to show subdivisions
        surf_subd = surface_create(img_w+1,img_h+1);
        surface_set_target(surf_subd);
        draw_clear_alpha(c_black,0);
        surface_reset_target();
        
        // list of nodes
        node_list = ds_list_create();
        
        // create new node
        var temp_node = ds_list_create();
        ds_list_add(node_list,temp_node);
        
        // set new nodes properties (xpos,ypos,w,h);
        ds_list_add(temp_node,0,0,img_w,img_h);
        }
    }

// move view
if (keyboard_check(ord("W")))
    view_yview[0] -= 4;
if (keyboard_check(ord("S")))
    view_yview[0] += 4;
if (keyboard_check(ord("A")))
    view_xview[0] -= 4;
if (keyboard_check(ord("D")))
    view_xview[0] += 4;

// scale
if (mouse_wheel_up())
    scale += 0.1;
if (mouse_wheel_down())
    scale -= 0.1;
scale = clamp(scale,0.1,4);

// reset view
if (keyboard_check(ord("R")))
    {
    scale = 1;
    view_xview[0] = 0;
    view_yview[0] = 0;
    }

// load custom image
if (keyboard_check(ord("E"))) and !(browser)
    {
    scr_cleanup();
    var file = get_open_filename("Image Files|*.png;*.jpg","");
    if (file_exists(file))
        {
        image = sprite_add(file,0,0,0,0,0);
        
        if (auto)
            alarm[0] = 20;
        }
    else
        {
        show_message("Failed to load custom image");
        image = spr_test1;
        
        if (auto)
            alarm[0] = 20;
        }
    }

// use pre-existing example image
for(var i=0; i&lt;3; i++;)
    {
    if (keyboard_check_pressed(ord(string(i+1))))
        {
        scr_cleanup();
        image = spr[i];
        
        if (auto)
            alarm[0] = 20;
        break;
        }
    }

if (keyboard_check(ord("Z")))
    help = !help;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="3">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>scr_cleanup();
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="64">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (ds_exists(node_list,ds_type_list))
    var size = ds_list_size(node_list);
else
    var size = 0;

if (help)
    {
    if (browser)
        {
        draw_set_color(c_black);
        draw_text(11,11,"#[WASD] and [R] to move/reset view, [Q] to hide cell boundaries#[123] to test example images#[Mouse Wheel] to scale image#fps: "+string(fps_real)+"#Nodes: "+string(size)+" / "+string(total));
        draw_text(11,13,"#[WASD] and [R] to move/reset view, [Q] to hide cell boundaries#[123] to test example images#[Mouse Wheel] to scale image#fps: "+string(fps_real)+"#Nodes: "+string(size)+" / "+string(total));
        draw_text(13,11,"#[WASD] and [R] to move/reset view, [Q] to hide cell boundaries#[123] to test example images#[Mouse Wheel] to scale image#fps: "+string(fps_real)+"#Nodes: "+string(size)+" / "+string(total));
        draw_text(13,13,"#[WASD] and [R] to move/reset view, [Q] to hide cell boundaries#[123] to test example images#[Mouse Wheel] to scale image#fps: "+string(fps_real)+"#Nodes: "+string(size)+" / "+string(total));
        draw_set_color(c_white);
        draw_text(12,12,"#[WASD] and [R] to move/reset view, [Q] to hide cell boundaries#[123] to test example images#[Mouse Wheel] to scale image#fps: "+string(fps_real)+"#Nodes: "+string(size)+" / "+string(total));
        }
    else
        {
        draw_set_color(c_black);
        draw_text(11,11,"#[WASD] and [R] to move/reset view, [Q] to hide cell boundaries#[123] to test example images / [E] to load custom image#[Mouse Wheel] to scale image#fps: "+string(fps_real)+"#Nodes: "+string(size)+" / "+string(total));
        draw_text(11,13,"#[WASD] and [R] to move/reset view, [Q] to hide cell boundaries#[123] to test example images / [E] to load custom image#[Mouse Wheel] to scale image#fps: "+string(fps_real)+"#Nodes: "+string(size)+" / "+string(total));
        draw_text(13,11,"#[WASD] and [R] to move/reset view, [Q] to hide cell boundaries#[123] to test example images / [E] to load custom image#[Mouse Wheel] to scale image#fps: "+string(fps_real)+"#Nodes: "+string(size)+" / "+string(total));
        draw_text(13,13,"#[WASD] and [R] to move/reset view, [Q] to hide cell boundaries#[123] to test example images / [E] to load custom image#[Mouse Wheel] to scale image#fps: "+string(fps_real)+"#Nodes: "+string(size)+" / "+string(total));
        draw_set_color(c_white);
        draw_text(12,12,"#[WASD] and [R] to move/reset view, [Q] to hide cell boundaries#[123] to test example images / [E] to load custom image#[Mouse Wheel] to scale image#fps: "+string(fps_real)+"#Nodes: "+string(size)+" / "+string(total));
        }
    }
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (init)
    {
    var xpos = (view_wview[0]/2) - ((img_w/2)*scale);
    var ypos = (view_hview[0]/2) - ((img_h/2)*scale);
    
    // draw original image and quadtree decomp image
    if (surface_exists(surf_quad))
        draw_surface_ext(surf_quad,xpos - ((img_w/2)*scale),ypos,scale,scale,0,-1,1);
    if (surface_exists(surf_data))
        draw_surface_ext(surf_data,xpos + ((img_w/2)*scale),ypos,scale,scale,0,-1,1);
    
    // draw subdivision boundaries
    if !(keyboard_check(ord("Q"))) and (surface_exists(surf_subd))
        draw_surface_ext(surf_subd,xpos - ((img_w/2)*scale),ypos,scale,scale,0,-1,1);
    }
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
