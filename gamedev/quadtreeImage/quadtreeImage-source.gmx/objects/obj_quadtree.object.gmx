<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// don't change these shift values unless you want to mess with the color sampling
if (os_browser == browser_not_a_browser)
    {
    b_shift = 0;
    g_shift = 8;
    r_shift = 16;
    }
else
    {
    b_shift = 16;
    g_shift = 8;
    r_shift = 0;
    }

image = spr_test;
quad_surf = -1;
subd_surf = -1;

// scaling
target_w = min(512,sprite_get_width(image));
target_h = min(512,sprite_get_height(image));

// filter settings
col_threshold = floor(0.20*255); // lower the threshold, the more sensitive
val_threshold = floor(0.10*255); // humans are more sensititve to luminosity
min_depth = 2; // min quad-tree splits
max_depth = 6; // max quad-tree splits

update = true;
node_list = ds_list_create();
var map = ds_map_create();
ds_map_add(map,"x1",0);
ds_map_add(map,"y1",0);
ds_map_add(map,"x2",target_w);
ds_map_add(map,"y2",target_h);
ds_map_add(map,"depth",0);
ds_list_add(node_list,map);

html5_sprite = -1;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (update)
    {
    update = false;
    show_debug_message("UPDATE!");
    
    var w = sprite_get_width(image);
    var h = sprite_get_height(image);
    
    // update scaling
    target_w = min(512,w);
    target_h = min(512,h);
    
    // draw the image to a surface
    var temp_surf = surface_create(target_w,target_h);
    surface_set_target(temp_surf);
    draw_clear($000000);
    draw_sprite_ext(image,0,0,0,target_w/w,target_h/h,0,-1,1);
    surface_reset_target();
    
    // put the surface data into a buffer so we can read color info
    // this is much faster than using surface_getpixel()
    temp_buff = buffer_create(target_w*target_h*4,buffer_grow,1);
    buffer_get_surface(temp_buff,temp_surf,0,0,0);
    surface_free(temp_surf);
    
    // get quad-tree surface ready
    if !(surface_exists(quad_surf))
        quad_surf = surface_create(target_w,target_h);
    surface_set_target(quad_surf);
    draw_clear($000000);
    draw_sprite_ext(image,0,0,0,target_w/w,target_h/h,0,-1,1);
    
    // split and render recursively
    var size = ds_list_size(node_list);
    while(size &gt; 0)
        {
        show_debug_message("NODES LEFT: "+string(size));
        
        var node = node_list[|size-1];
        ds_list_delete(node_list,size-1);
        
        var node_x1 = node[?"x1"];
        var node_y1 = node[?"y1"];
        var node_x2 = node[?"x2"];
        var node_y2 = node[?"y2"];
        var node_depth = node[?"depth"]; // passes
        ds_map_destroy(node);
        
        for(var ix=0; ix&lt;2; ix++;)
            {
            for(var iy=0; iy&lt;2; iy++;)
                {
                var hw = round((target_w/power(2,node_depth))/2); // half node width
                var hh = round((target_h/power(2,node_depth))/2); // half node height
                var x1 = node_x1 + hw*ix;
                var y1 = node_y1 + hh*iy;
                var x2 = x1 + hw;
                var y2 = y1 + hh;
                
                offset_00 = (min(y1,target_h-1)*target_w + min(x1,target_w-1))*4;
                offset_01 = (min(y2,target_h-1)*target_w + min(x1,target_w-1))*4;
                offset_10 = (min(y1,target_h-1)*target_w + min(x2,target_w-1))*4;
                offset_11 = (min(y2,target_h-1)*target_w + min(x2,target_w-1))*4;
                
                var raw;
                raw[0,0] = buffer_peek(temp_buff,offset_00,buffer_u32);
                raw[0,1] = buffer_peek(temp_buff,offset_01,buffer_u32);
                raw[1,0] = buffer_peek(temp_buff,offset_10,buffer_u32);
                raw[1,1] = buffer_peek(temp_buff,offset_11,buffer_u32);
                
                for(var jx=0; jx&lt;2; jx++;)
                    {
                    for(var jy=0; jy&lt;2; jy++;)
                        {
                        var b, g, r, v;
                        b[jx,jy] = (raw[jx,jy] &gt;&gt; b_shift) &amp; 255;
                        g[jx,jy] = (raw[jx,jy] &gt;&gt; g_shift) &amp; 255;
                        r[jx,jy] = (raw[jx,jy] &gt;&gt; r_shift) &amp; 255;
                        v[jx,jy] = max(b[jx,jy],g[jx,jy],r[jx,jy]);
                        }
                    }
                
                var col_diff_t  = max(abs(b[0,0]-b[1,0]),abs(g[0,0]-g[1,0]),abs(r[0,0]-r[1,0]));
                var val_diff_t  = abs(v[0,0]-v[1,0]);
                var col_diff_b  = max(abs(b[0,1]-b[1,1]),abs(g[0,1]-g[1,1]),abs(r[0,1]-r[1,1]));
                var val_diff_b  = abs(v[0,1]-v[1,1]);
                var col_diff_l  = max(abs(b[0,0]-b[0,1]),abs(g[0,0]-g[0,1]),abs(r[0,0]-r[0,1]));
                var val_diff_l  = abs(v[0,0]-v[0,1]);
                var col_diff_r  = max(abs(b[1,0]-b[1,1]),abs(g[1,0]-g[1,1]),abs(r[1,0]-r[1,1]));
                var val_diff_r  = abs(v[1,0]-v[1,1]);
                var col_diff_d1 = max(abs(b[0,0]-b[1,1]),abs(g[0,0]-g[1,1]),abs(r[0,0]-r[1,1]));
                var val_diff_d1 = abs(v[0,0]-v[1,1]);
                var col_diff_d2 = max(abs(b[1,0]-b[0,1]),abs(g[1,0]-g[0,1]),abs(r[1,0]-r[0,1]));
                var val_diff_d2 = abs(v[1,0]-v[0,1]);
                
                var col_diff = max(col_diff_t,col_diff_b,col_diff_l,col_diff_r,col_diff_d1,col_diff_d2);
                var val_diff = max(val_diff_t,val_diff_b,val_diff_l,val_diff_r,val_diff_d1,val_diff_d2);
                
                // draw to surface
                draw_set_color(make_color_rgb(r[0,0],g[0,0],b[0,0]));
                draw_rectangle(x1,y1,x2,y2,0);
                
                if (col_diff &gt; col_threshold)
                or (val_diff &gt; val_threshold)
                or (node_depth &lt; min_depth)
                    {
                    // split
                    if (node_depth &lt; max_depth)
                        {
                        var map = ds_map_create();
                        ds_map_add(map,"x1",x1);
                        ds_map_add(map,"y1",y1);
                        ds_map_add(map,"x2",x2);
                        ds_map_add(map,"y2",y2);
                        ds_map_add(map,"depth",node_depth+1);
                        ds_list_add(node_list,map);
                        }
                    }
                }
            }
        
        var size = ds_list_size(node_list);
        }
    
    surface_reset_target();
    
    buffer_delete(temp_buff);
    ds_list_clear(node_list);
    }

// load custom image
if (keyboard_check(ord("E")))
    {
    file = "";
    if (os_browser == browser_not_a_browser)
        var file = get_open_filename("Image Files|*.png;*.jpg","");
    if (file_exists(file))
        {
        if (image != spr_test)
            sprite_delete(image);
        
        image = sprite_add(file,0,0,0,0,0);
        
        // cleanup
        ds_list_clear(node_list);
        if (surface_exists(quad_surf))
            surface_free(quad_surf);
        quad_surf = -1;
        
        // queue the update info
        update = true;
        node_list = ds_list_create();
        var map = ds_map_create();
        ds_map_add(map,"x1",0);
        ds_map_add(map,"y1",0);
        ds_map_add(map,"x2",target_w);
        ds_map_add(map,"y2",target_h);
        ds_map_add(map,"depth",0);
        ds_list_add(node_list,map);
        }
    }
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (sprite_exists(html5_sprite))
    draw_sprite(html5_sprite,0,0,0);

if (keyboard_check(vk_space))
    {
    if (sprite_exists(image))
        {
        var w = sprite_get_width(image);
        var h = sprite_get_height(image);
        draw_sprite_ext(image,0,room_width/2-target_w/2,room_height/2-target_h/2,target_w/w,target_h/h,0,-1,1);
        }
    }
else
    {
    if (surface_exists(quad_surf))
        draw_surface(quad_surf,room_width/2-target_w/2,room_height/2-target_h/2);
    }
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
